-- ============================================================================
-- Migration: Initial Schema for 10x-cards
-- ============================================================================
-- Description: Creates the complete database schema for the 10x-cards MVP
-- including decks, cards, and generation_sessions tables with full RLS
-- policies, indexes, triggers, and helper functions.
--
-- Tables Created:
--   - decks: User flashcard decks with draft/published/rejected workflow
--   - cards: Individual flashcards belonging to decks
--   - generation_sessions: AI generation tracking (1:1 with decks)
--
-- Security: Row Level Security enabled on all tables with granular policies
-- Performance: Optimized indexes for common queries and constraints
-- ============================================================================

-- ============================================================================
-- EXTENSIONS
-- ============================================================================

-- Enable citext extension for case-insensitive text columns
create extension if not exists citext;

-- ============================================================================
-- TABLE: decks
-- ============================================================================
-- Stores user flashcard decks with workflow status management
-- Status flow: draft -> published OR draft -> rejected
-- Published decks are read-only (enforced by RLS)
-- ============================================================================

create table decks (
  -- Primary key: UUID generated by PostgreSQL
  id uuid primary key default gen_random_uuid(),

  -- Owner reference: Links to Supabase Auth user
  -- CASCADE: When user is deleted, all their decks are deleted
  user_id uuid not null references auth.users(id) on delete cascade,

  -- Deck name: Case-insensitive, 1-100 characters
  -- Using CITEXT for case-insensitive uniqueness per user
  name citext not null,
  constraint decks_name_length check (char_length(name) between 1 and 100),

  -- URL slug: Auto-generated from name via trigger
  slug text not null,

  -- Workflow status: Controls deck lifecycle
  -- draft: Editable by owner
  -- published: Read-only, visible to public (future feature)
  -- rejected: User-rejected draft, can be deleted or revised
  status text not null default 'draft',
  constraint decks_status_values check (status in ('draft', 'published', 'rejected')),

  -- Publication timestamp: Set when status changes to 'published'
  published_at timestamptz,

  -- Rejection metadata: Set when status changes to 'rejected'
  rejected_at timestamptz,
  rejected_reason text,
  constraint decks_rejected_reason_length check (
    rejected_reason is null or char_length(rejected_reason) <= 500
  ),

  -- Soft delete: Allows name reuse and maintains audit trail
  deleted_at timestamptz,

  -- Timestamps: Automatically managed by triggers
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Enable Row Level Security on decks table
-- Strategy: deny-by-default, explicit grants via policies
alter table decks enable row level security;

-- ============================================================================
-- TABLE: cards
-- ============================================================================
-- Stores individual flashcards belonging to decks
-- Cards inherit read-only status from parent deck
-- Position determines card order within deck (1-based indexing)
-- ============================================================================

create table cards (
  -- Primary key: UUID generated by PostgreSQL
  id uuid primary key default gen_random_uuid(),

  -- Parent deck reference: Links to deck
  -- CASCADE: When deck is deleted, all its cards are deleted
  deck_id uuid not null references decks(id) on delete cascade,

  -- Card content: Front (question) and back (answer)
  -- Max 200 characters each for MVP
  front text not null,
  constraint cards_front_length check (char_length(front) between 1 and 200),

  back text not null,
  constraint cards_back_length check (char_length(back) between 1 and 200),

  -- Card position: 1-based ordering within deck
  -- Unique per deck (enforced by partial unique index)
  -- Normalization (gap removal) handled by application logic
  position integer not null,
  constraint cards_position_positive check (position > 0),

  -- Optional hint: Reserved for future feature
  hint text,
  constraint cards_hint_length check (
    hint is null or char_length(hint) <= 200
  ),

  -- Active flag: Reserved for future card disable feature
  is_active boolean not null default true,

  -- Locale: Reserved for multi-language support
  -- Format: ISO 639-1 codes (e.g., 'pl', 'en')
  locale text,
  constraint cards_locale_length check (
    locale is null or char_length(locale) <= 10
  ),

  -- Flexible metadata: JSONB for future extensibility
  -- Examples: tags, difficulty, learning algorithm state
  metadata jsonb,

  -- Soft delete: Cascaded from parent deck via trigger
  deleted_at timestamptz,

  -- Timestamps: Automatically managed by triggers
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Enable Row Level Security on cards table
alter table cards enable row level security;

-- ============================================================================
-- TABLE: generation_sessions
-- ============================================================================
-- Tracks AI generation sessions for decks (1:1 relationship)
-- Enforces: max 1 active session per user via partial unique index
-- Stores generation parameters and sanitized input for audit/debugging
-- ============================================================================

create table generation_sessions (
  -- Primary key: UUID generated by PostgreSQL
  id uuid primary key default gen_random_uuid(),

  -- User reference: Who initiated the generation
  -- CASCADE: When user is deleted, their generation history is deleted
  user_id uuid not null references auth.users(id) on delete cascade,

  -- Deck reference: 1:1 relationship with deck
  -- CASCADE: When deck is deleted, its generation session is deleted
  -- UNIQUE: Each deck can have at most one generation session
  deck_id uuid not null unique references decks(id) on delete cascade,

  -- Generation status: Tracks lifecycle of AI generation
  -- in_progress: Currently generating (max 1 per user via partial index)
  -- completed: Successfully generated cards
  -- failed: Error during generation (see error_code/error_message)
  -- timeout: Generation exceeded 5-minute limit
  status text not null default 'in_progress',
  constraint gen_sessions_status_values check (
    status in ('in_progress', 'completed', 'failed', 'timeout')
  ),

  -- Generation parameters: JSONB for flexibility
  -- Examples: model name, temperature, max_tokens, prompt version
  params jsonb,

  -- Sanitized input: Cleaned source text used for generation
  -- Max 10k characters after sanitization
  -- Stored for audit, debugging, and potential regeneration
  sanitized_source_text text not null,
  constraint gen_sessions_source_text_length check (
    char_length(sanitized_source_text) <= 10000
  ),

  -- Truncation tracking: How many cards were cut to reach 20-card limit
  -- NULL if LLM returned â‰¤20 cards
  truncated_count smallint,
  constraint gen_sessions_truncated_count_positive check (
    truncated_count is null or truncated_count >= 0
  ),

  -- Error tracking: Only populated when status = 'failed'
  -- error_code: Machine-readable code (e.g., 'rate_limit', 'invalid_response')
  -- error_message: Human-readable details for debugging
  error_code text,
  error_message text,
  constraint gen_sessions_error_message_length check (
    error_message is null or char_length(error_message) <= 1000
  ),

  -- Timing: Track generation duration for monitoring
  started_at timestamptz not null default now(),
  finished_at timestamptz,

  -- Timestamps: Automatically managed by triggers
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Enable Row Level Security on generation_sessions table
alter table generation_sessions enable row level security;

-- ============================================================================
-- INDEXES: Performance optimization
-- ============================================================================

-- ---------------------------------------------------------------------------
-- Decks Indexes
-- ---------------------------------------------------------------------------

-- Index: Fast listing of user's decks with status filtering and sorting
-- Usage: Dashboard, deck list page
-- WHERE clause: Exclude soft-deleted decks from index
create index idx_decks_user_id_status_updated
on decks(user_id, status, updated_at desc)
where deleted_at is null;

-- Index: Enforce unique deck name per user (case-insensitive)
-- Partial: Only active (non-deleted) decks
-- Allows name reuse after soft-delete
create unique index idx_decks_user_name_unique
on decks(user_id, lower(name))
where deleted_at is null;

-- Index: Fast deck lookup by slug for URL routing
-- Usage: /decks/:slug page
create index idx_decks_slug
on decks(slug)
where deleted_at is null;

-- ---------------------------------------------------------------------------
-- Cards Indexes
-- ---------------------------------------------------------------------------

-- Index: Fetch cards in position order for a deck
-- Usage: Deck view, card editing, publishing
-- Composite: Efficient for both WHERE deck_id and ORDER BY position
create index idx_cards_deck_id_position
on cards(deck_id, position)
where deleted_at is null;

-- Index: Enforce unique position per deck
-- Partial: Only active (non-deleted) cards
-- Prevents duplicate positions within a deck
create unique index idx_cards_deck_position_unique
on cards(deck_id, position)
where deleted_at is null;

-- ---------------------------------------------------------------------------
-- Generation Sessions Indexes
-- ---------------------------------------------------------------------------

-- Index: List user's generation history sorted by recency
-- Usage: Generation history page
create index idx_gen_sessions_user_created
on generation_sessions(user_id, created_at desc);

-- Index: Enforce max 1 active generation per user
-- Partial: Only in_progress sessions
-- Prevents race conditions when starting new generations
create unique index idx_gen_sessions_user_in_progress
on generation_sessions(user_id)
where status = 'in_progress';

-- ============================================================================
-- FUNCTIONS: Helper utilities
-- ============================================================================

-- ---------------------------------------------------------------------------
-- Function: update_updated_at_column
-- ---------------------------------------------------------------------------
-- Automatically sets updated_at = NOW() on every UPDATE
-- Used by triggers on all tables
-- ---------------------------------------------------------------------------

create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- ---------------------------------------------------------------------------
-- Function: slugify
-- ---------------------------------------------------------------------------
-- Converts text to URL-friendly slug
-- Rules:
--   - Lowercase
--   - Remove non-alphanumeric (except spaces and hyphens)
--   - Replace spaces/multiple hyphens with single hyphen
--   - Trim leading/trailing hyphens
-- IMMUTABLE: Same input always produces same output
-- ---------------------------------------------------------------------------

create or replace function slugify(text_input text)
returns text as $$
declare
  result text;
begin
  -- Convert to lowercase and trim whitespace
  result := lower(trim(text_input));

  -- Remove all non-alphanumeric characters except spaces and hyphens
  result := regexp_replace(result, '[^a-z0-9\s-]', '', 'g');

  -- Replace one or more spaces/hyphens with single hyphen
  result := regexp_replace(result, '[\s-]+', '-', 'g');

  -- Trim leading and trailing hyphens
  result := trim(both '-' from result);

  return result;
end;
$$ language plpgsql immutable;

-- ---------------------------------------------------------------------------
-- Function: generate_deck_slug
-- ---------------------------------------------------------------------------
-- Trigger function to auto-generate deck slug from name
-- Runs on INSERT and UPDATE of name column
-- ---------------------------------------------------------------------------

create or replace function generate_deck_slug()
returns trigger as $$
begin
  new.slug := slugify(new.name);
  return new;
end;
$$ language plpgsql;

-- ---------------------------------------------------------------------------
-- Function: soft_delete_deck_cards
-- ---------------------------------------------------------------------------
-- Trigger function for cascading soft-delete
-- When deck.deleted_at is set, marks all its cards as deleted
-- Preserves data for audit trail while maintaining referential integrity
-- ---------------------------------------------------------------------------

create or replace function soft_delete_deck_cards()
returns trigger as $$
begin
  -- Only act if deleted_at changed from NULL to a timestamp
  if new.deleted_at is not null and old.deleted_at is null then
    -- Soft-delete all non-deleted cards in this deck
    update cards
    set deleted_at = new.deleted_at
    where deck_id = new.id
    and deleted_at is null;
  end if;

  return new;
end;
$$ language plpgsql;

-- ---------------------------------------------------------------------------
-- Function: publish_deck (RPC)
-- ---------------------------------------------------------------------------
-- SECURITY DEFINER: Atomically publishes a deck with validations
-- Workflow:
--   1. Validate ownership, status (must be draft), card count (1-20)
--   2. Acquire advisory lock to prevent race conditions
--   3. Hard-delete cards beyond top 20 (by position)
--   4. Set status = 'published', published_at = NOW()
-- Returns: JSONB with success/error status
-- Accessible by: authenticated users
-- ---------------------------------------------------------------------------

create or replace function publish_deck(deck_id_param uuid)
returns jsonb
language plpgsql
security definer
as $$
declare
  deck_record record;
  card_count integer;
begin
  -- Acquire transaction-scoped advisory lock on deck
  -- Prevents concurrent publish attempts on same deck
  perform pg_advisory_xact_lock(hashtext(deck_id_param::text));

  -- Fetch deck with row-level lock
  select * into deck_record
  from decks
  where id = deck_id_param
  for update;

  -- Validation: Deck exists
  if not found then
    return jsonb_build_object(
      'success', false,
      'error', 'deck_not_found'
    );
  end if;

  -- Validation: User is deck owner
  if deck_record.user_id != auth.uid() then
    return jsonb_build_object(
      'success', false,
      'error', 'unauthorized'
    );
  end if;

  -- Validation: Deck is in draft status
  if deck_record.status != 'draft' then
    return jsonb_build_object(
      'success', false,
      'error', 'deck_not_draft'
    );
  end if;

  -- Validation: Deck is not soft-deleted
  if deck_record.deleted_at is not null then
    return jsonb_build_object(
      'success', false,
      'error', 'deck_deleted'
    );
  end if;

  -- Count active cards in deck
  select count(*) into card_count
  from cards
  where deck_id = deck_id_param
  and deleted_at is null;

  -- Validation: Deck has between 1 and 20 cards
  if card_count < 1 or card_count > 20 then
    return jsonb_build_object(
      'success', false,
      'error', 'invalid_card_count',
      'card_count', card_count
    );
  end if;

  -- Hard-delete cards beyond top 20 (ordered by position)
  -- DESTRUCTIVE: This permanently removes cards to enforce 20-card limit
  delete from cards
  where deck_id = deck_id_param
  and deleted_at is null
  and position > (
    select position
    from cards
    where deck_id = deck_id_param
    and deleted_at is null
    order by position asc
    limit 1 offset 19
  );

  -- Publish the deck
  update decks
  set
    status = 'published',
    published_at = now(),
    updated_at = now()
  where id = deck_id_param;

  return jsonb_build_object(
    'success', true,
    'deck_id', deck_id_param
  );
end;
$$;

-- Grant execute permission to authenticated users
grant execute on function publish_deck(uuid) to authenticated;

-- ---------------------------------------------------------------------------
-- Function: reject_deck (RPC)
-- ---------------------------------------------------------------------------
-- SECURITY DEFINER: Atomically rejects a draft deck
-- Workflow:
--   1. Validate ownership and status (must be draft)
--   2. Acquire advisory lock to prevent race conditions
--   3. Set status = 'rejected', rejected_at = NOW(), rejected_reason
-- Returns: JSONB with success/error status
-- Accessible by: authenticated users
-- ---------------------------------------------------------------------------

create or replace function reject_deck(
  deck_id_param uuid,
  reason_param text default null
)
returns jsonb
language plpgsql
security definer
as $$
declare
  deck_record record;
begin
  -- Acquire transaction-scoped advisory lock on deck
  perform pg_advisory_xact_lock(hashtext(deck_id_param::text));

  -- Fetch deck with row-level lock
  select * into deck_record
  from decks
  where id = deck_id_param
  for update;

  -- Validation: Deck exists
  if not found then
    return jsonb_build_object(
      'success', false,
      'error', 'deck_not_found'
    );
  end if;

  -- Validation: User is deck owner
  if deck_record.user_id != auth.uid() then
    return jsonb_build_object(
      'success', false,
      'error', 'unauthorized'
    );
  end if;

  -- Validation: Deck is in draft status
  if deck_record.status != 'draft' then
    return jsonb_build_object(
      'success', false,
      'error', 'deck_not_draft'
    );
  end if;

  -- Reject the deck
  update decks
  set
    status = 'rejected',
    rejected_at = now(),
    rejected_reason = reason_param,
    updated_at = now()
  where id = deck_id_param;

  return jsonb_build_object(
    'success', true,
    'deck_id', deck_id_param
  );
end;
$$;

-- Grant execute permission to authenticated users
grant execute on function reject_deck(uuid, text) to authenticated;

-- ============================================================================
-- TRIGGERS: Automatic column management
-- ============================================================================

-- ---------------------------------------------------------------------------
-- Trigger: Auto-update updated_at on decks
-- ---------------------------------------------------------------------------
create trigger set_updated_at_decks
before update on decks
for each row
execute function update_updated_at_column();

-- ---------------------------------------------------------------------------
-- Trigger: Auto-update updated_at on cards
-- ---------------------------------------------------------------------------
create trigger set_updated_at_cards
before update on cards
for each row
execute function update_updated_at_column();

-- ---------------------------------------------------------------------------
-- Trigger: Auto-update updated_at on generation_sessions
-- ---------------------------------------------------------------------------
create trigger set_updated_at_generation_sessions
before update on generation_sessions
for each row
execute function update_updated_at_column();

-- ---------------------------------------------------------------------------
-- Trigger: Auto-generate deck slug from name
-- ---------------------------------------------------------------------------
create trigger set_deck_slug
before insert or update of name on decks
for each row
execute function generate_deck_slug();

-- ---------------------------------------------------------------------------
-- Trigger: Cascade soft-delete from deck to cards
-- ---------------------------------------------------------------------------
create trigger cascade_soft_delete_cards
after update of deleted_at on decks
for each row
when (new.deleted_at is not null and old.deleted_at is null)
execute function soft_delete_deck_cards();

-- ============================================================================
-- ROW LEVEL SECURITY POLICIES
-- ============================================================================
-- Strategy: deny-by-default, explicit grants
-- All policies check auth.uid() to ensure user ownership
-- ============================================================================

-- ---------------------------------------------------------------------------
-- RLS Policies: decks
-- ---------------------------------------------------------------------------

-- Policy: SELECT - Users can view their own non-deleted decks (all statuses)
create policy "Users can view their own decks"
on decks for select
to authenticated
using (
  user_id = auth.uid()
  and deleted_at is null
);

-- Policy: SELECT - Anonymous users can view published decks (future feature)
create policy "Anonymous users can view published decks"
on decks for select
to anon
using (
  status = 'published'
  and deleted_at is null
);

-- Policy: INSERT - Users can create new decks (must be draft, owned by them)
create policy "Users can create their own decks"
on decks for insert
to authenticated
with check (
  user_id = auth.uid()
  and status = 'draft'
  and deleted_at is null
);

-- Policy: UPDATE - Users can update their own draft decks
-- USING: Can only update decks they own, that are draft and not deleted
-- WITH CHECK: After update, deck must still be owned by them and not deleted
create policy "Users can update their own draft decks"
on decks for update
to authenticated
using (
  user_id = auth.uid()
  and status = 'draft'
  and deleted_at is null
)
with check (
  user_id = auth.uid()
  and deleted_at is null
);

-- Policy: UPDATE - Users can soft-delete their own decks (any status)
-- USING: Can only delete decks they own that are not already deleted
-- WITH CHECK: After update, deleted_at must be set
create policy "Users can soft-delete their own decks"
on decks for update
to authenticated
using (
  user_id = auth.uid()
  and deleted_at is null
)
with check (
  user_id = auth.uid()
  and deleted_at is not null
);

-- ---------------------------------------------------------------------------
-- RLS Policies: cards
-- ---------------------------------------------------------------------------

-- Policy: SELECT - Users can view cards from their own non-deleted decks
create policy "Users can view cards from their own decks"
on cards for select
to authenticated
using (
  exists (
    select 1 from decks
    where decks.id = cards.deck_id
    and decks.user_id = auth.uid()
    and decks.deleted_at is null
  )
  and cards.deleted_at is null
);

-- Policy: SELECT - Anonymous users can view cards from published decks (future)
create policy "Anonymous users can view cards from published decks"
on cards for select
to anon
using (
  exists (
    select 1 from decks
    where decks.id = cards.deck_id
    and decks.status = 'published'
    and decks.deleted_at is null
  )
  and cards.deleted_at is null
);

-- Policy: INSERT - Users can add cards to their own draft decks
create policy "Users can insert cards into their draft decks"
on cards for insert
to authenticated
with check (
  exists (
    select 1 from decks
    where decks.id = cards.deck_id
    and decks.user_id = auth.uid()
    and decks.status = 'draft'
    and decks.deleted_at is null
  )
  and cards.deleted_at is null
);

-- Policy: UPDATE - Users can update cards in their own draft decks
create policy "Users can update cards in their draft decks"
on cards for update
to authenticated
using (
  exists (
    select 1 from decks
    where decks.id = cards.deck_id
    and decks.user_id = auth.uid()
    and decks.status = 'draft'
    and decks.deleted_at is null
  )
  and cards.deleted_at is null
)
with check (
  exists (
    select 1 from decks
    where decks.id = cards.deck_id
    and decks.user_id = auth.uid()
    and decks.status = 'draft'
    and decks.deleted_at is null
  )
  and cards.deleted_at is null
);

-- Policy: UPDATE - Users can soft-delete cards in their own draft decks
create policy "Users can soft-delete cards in their draft decks"
on cards for update
to authenticated
using (
  exists (
    select 1 from decks
    where decks.id = cards.deck_id
    and decks.user_id = auth.uid()
    and decks.status = 'draft'
    and decks.deleted_at is null
  )
  and cards.deleted_at is null
)
with check (
  exists (
    select 1 from decks
    where decks.id = cards.deck_id
    and decks.user_id = auth.uid()
    and decks.status = 'draft'
  )
  and cards.deleted_at is not null
);

-- ---------------------------------------------------------------------------
-- RLS Policies: generation_sessions
-- ---------------------------------------------------------------------------

-- Policy: SELECT - Users can view their own generation sessions
create policy "Users can view their own generation sessions"
on generation_sessions for select
to authenticated
using (user_id = auth.uid());

-- Note: No INSERT/UPDATE policies for authenticated users
-- Generation sessions are created/updated by backend using service role
-- This prevents users from tampering with generation state

-- ============================================================================
-- COMMENTS: Table and column documentation
-- ============================================================================

comment on table decks is 'User flashcard decks with draft/published/rejected workflow';
comment on column decks.slug is 'URL-friendly slug auto-generated from name';
comment on column decks.status is 'Workflow status: draft (editable) | published (read-only) | rejected';
comment on column decks.deleted_at is 'Soft delete timestamp, allows name reuse';

comment on table cards is 'Individual flashcards belonging to decks';
comment on column cards.position is '1-based ordering within deck, unique per deck';
comment on column cards.hint is 'Optional hint for learner (reserved for future)';
comment on column cards.is_active is 'Active flag for card disable feature (reserved for future)';
comment on column cards.metadata is 'Flexible JSONB for future extensions (tags, difficulty, etc.)';

comment on table generation_sessions is 'AI generation tracking with 1:1 relationship to decks';
comment on column generation_sessions.deck_id is 'Unique per deck (1:1 relationship)';
comment on column generation_sessions.sanitized_source_text is 'Cleaned input text for audit and potential regeneration';
comment on column generation_sessions.truncated_count is 'Number of cards cut to reach 20-card limit';

-- ============================================================================
-- END OF MIGRATION
-- ============================================================================
